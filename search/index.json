[{"content":"字符串 char *p=\u0026#34;Hello World\u0026#34;; //\u0026#34;Hello World\u0026#34;字符串存储在常量存储区中,属于只读存储区,不能进行写操作 *p=\u0026#39;w\u0026#39;;//错误写法 char str[]=\u0026#34;Hello World\u0026#34;; //若在函数内定义就分配到栈中，属于局部变量 //若在全局分配或用static关键词修饰则存储在静态存储区 str=\u0026#34;Hello\u0026#34;;//错误,数组是常量指针，不能修改其地址内容 即不能作为左值但是其内容是可以修改的 str[0]=\u0026#39;w\u0026#39;;//正确 p=str; p=\u0026amp;str[0];//二者等价 scanf() 遇 到空白字符空格 Tab 回车 就代表输入结束\ngets()遇到回车结束。过程：把回车从缓存区中读走但是不作为字符串的一部分\n\u0026quot;%*c\u0026quot; 读入一个字符，但忽略它（即不赋值给任何变量）。\n当 cin\u0026raquo; 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin\u0026raquo; 会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin\u0026raquo; 不做处理。\ncin\u0026raquo; 对缓冲区中的第一个换行符视而不见，采取的措施是忽略清除，继续阻塞等待缓冲区有效数据的到来。但是，getline() 读取数据时，并非像 cin\u0026raquo; 那样忽略第一个换行符，getline() 发现 cin 的缓冲区中有一个残留的换行符，不阻塞请求键盘输入，直接读取，送入目标字符串后，因为读取的内容为空，所以程序中的变量 test 为空串。\n作用域和生存期 static int a = 1 在gcc test.c时赋初值为1且只初始化一次。若是全局静态变量仅能在test.c中使用（多文件时候静态全局变量可以重名），若是静态局部变量只能在{}中间使用，但再次调用时候因为地址没有变化所以值没有变化。\n不是静态的全局变量在其他文件中也能使用。\n初始化问题 静态变量和全局变量因为在静态存储区，所以在没有初始化时赋初值为0\nauto局部变量在没有赋值时，赋的是随机值\n","date":"0001-01-01T00:00:00Z","permalink":"https://Jackwyf2019.github.io/p/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"C语言复习笔记"},{"content":"CORS 跨域：协议，域名，端口任意一个不同都会导致跨域\nRequest Method:OPTIONS 预检请求 nginx部署为同一个域 响应头允许跨域 使用Springboot提供的filter\n@Bean public CorsWebFilter corsWebFilter(){ UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration = new CorsConfiguration(); //1、配置跨域  corsConfiguration.addAllowedHeader(\u0026#34;*\u0026#34;); corsConfiguration.addAllowedMethod(\u0026#34;*\u0026#34;); corsConfiguration.addAllowedOrigin(\u0026#34;*\u0026#34;); corsConfiguration.setAllowCredentials(true); //注册配置  source.registerCorsConfiguration(\u0026#34;/**\u0026#34;,corsConfiguration); return new CorsWebFilter(source); } Stream @Override public List\u0026lt;CategoryEntity\u0026gt; listTree() { //查询出所有项  List\u0026lt;CategoryEntity\u0026gt; entities = baseMapper.selectList(null); //查出所有项的根结点  List\u0026lt;CategoryEntity\u0026gt; roots = entities.stream().filter((entity) -\u0026gt; { return entity.getParentCid() == 0; }).map((root) -\u0026gt; { root.setChildren(getChildren(root, entities)); return root; }).sorted((e1, e2) -\u0026gt; { return (e1.getSort()==null?0:e1.getSort())-(e2.getSort()==null?0:e2.getSort()); }).collect(Collectors.toList()); return roots; } .sorted需要判空，因为可能list中没有数据或者只有一个数据\n.map如果流总没有数据则不执行所以最优collect的list是[]\ngateway 路径重写\n- id:product_routeuri:lb://gulimall-productpredicates:- Path=/api/product/**filters:- RewritePath=/api/(?\u0026lt;segment\u0026gt;.*),/$\\{segment}@EnableDiscoveryClient 开启注册发现功能 精确的路由需要放在高优先级\nSpringboot @RequestBody 获取请求体，必须发送POST请求\n将请求体中的数据（JSON）转换为相应的对象\n 两个等价的注解\n @RequestMapping(value = \u0026#34;/catelog/list\u0026#34;,method = RequestMethod.GET) @GetMapping(\u0026#34;/catelog/list\u0026#34;) 校验 JSR303 javax.\n@NotBlank @Valid\n@NotBlank(message = \u0026quot;品牌名必须提交\u0026quot;)\n错误信息\n{ \u0026#34;timestamp\u0026#34;: \u0026#34;2021-02-09 09:10:14\u0026#34;, \u0026#34;status\u0026#34;: 400, \u0026#34;error\u0026#34;: \u0026#34;Bad Request\u0026#34;, \u0026#34;errors\u0026#34;: [ { \u0026#34;codes\u0026#34;: [ \u0026#34;NotBlank.brandEntity.name\u0026#34;, \u0026#34;NotBlank.name\u0026#34;, \u0026#34;NotBlank.java.lang.String\u0026#34;, \u0026#34;NotBlank\u0026#34; ], \u0026#34;arguments\u0026#34;: [ { \u0026#34;codes\u0026#34;: [ \u0026#34;brandEntity.name\u0026#34;, \u0026#34;name\u0026#34; ], \u0026#34;arguments\u0026#34;: null, \u0026#34;defaultMessage\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;name\u0026#34; } ], \u0026#34;defaultMessage\u0026#34;: \u0026#34;不能为空\u0026#34;, \u0026#34;objectName\u0026#34;: \u0026#34;brandEntity\u0026#34;, \u0026#34;field\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;rejectedValue\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;bindingFailure\u0026#34;: false, \u0026#34;code\u0026#34;: \u0026#34;NotBlank\u0026#34; } ], \u0026#34;message\u0026#34;: \u0026#34;Validation failed for object=\u0026#39;brandEntity\u0026#39;. Error count: 1\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/product/brand/save\u0026#34; } @RequestMapping(\u0026#34;/save\u0026#34;) //@RequiresPermissions(\u0026#34;product:brand:save\u0026#34;)  public R save(@Valid @RequestBody BrandEntity brand, BindingResult result){ brandService.save(brand); return R.ok(); }  BindingResult 存校验结果\n 示例 @Data @TableName(\u0026#34;pms_brand\u0026#34;) public class BrandEntity implements Serializable { private static final long serialVersionUID = 1L; /** * 品牌id */ @TableId private Long brandId; /** * 品牌名 */ @NotBlank(message = \u0026#34;品牌名必须提交\u0026#34;) private String name; /** * 品牌logo地址 */ @NotEmpty @URL(message = \u0026#34;logo必须是一个合法的url地址\u0026#34;) private String logo; /** * 介绍 */ private String descript; /** * 显示状态[0-不显示；1-显示] */ private Integer showStatus; /** * 检索首字母 */ @NotEmpty @Pattern(regexp = \u0026#34;/^[a-zA-Z]$/\u0026#34;,message = \u0026#34;检索首字母必须是一个字母\u0026#34;) private String firstLetter; /** * 排序 */ @NotNull @Min(value = 0,message = \u0026#34;排序必须大于0\u0026#34;) private Integer sort; } /** * 保存 */ @RequestMapping(\u0026#34;/save\u0026#34;) //@RequiresPermissions(\u0026#34;product:brand:save\u0026#34;)  public R save(@Valid @RequestBody BrandEntity brand, BindingResult result){ //校验  if(result.hasErrors()){ Map\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); //遍历所有属性错误  result.getFieldErrors().forEach((item)-\u0026gt;{ //错误信息  String message = item.getDefaultMessage(); //错误属性名  String field = item.getField(); map.put(field,message); }); return R.error(400,\u0026#34;提交数据不合法\u0026#34;).put(\u0026#34;data\u0026#34;,map); }else{ brandService.save(brand); return R.ok(); } } 总结 /** * 1、整合MyBatis-Plus * 1）、导入依赖 * \u0026lt;dependency\u0026gt; * \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; * \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; * \u0026lt;version\u0026gt;3.2.0\u0026lt;/version\u0026gt; * \u0026lt;/dependency\u0026gt; * 2）、配置 * 1、配置数据源； * 1）、导入数据库的驱动。https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-versions.html * 2）、在application.yml配置数据源相关信息 * 2、配置MyBatis-Plus； * 1）、使用@MapperScan * 2）、告诉MyBatis-Plus，sql映射文件位置 * * 2、逻辑删除 * 1）、配置全局的逻辑删除规则（省略） * 2）、配置逻辑删除的组件Bean（省略） * 3）、给Bean加上逻辑删除注解@TableLogic * * 3、JSR303 * 1）、给Bean添加校验注解:javax.validation.constraints，并定义自己的message提示 * 2)、开启校验功能@Valid * 效果：校验错误以后会有默认的响应； * 3）、给校验的bean后紧跟一个BindingResult，就可以获取到校验的结果 * 4）、分组校验（多场景的复杂校验） * 1)、\t@NotBlank(message = \u0026quot;品牌名必须提交\u0026quot;,groups = {AddGroup.class,UpdateGroup.class}) * 给校验注解标注什么情况需要进行校验 * 2）、@Validated({AddGroup.class}) * 3)、默认没有指定分组的校验注解@NotBlank，在分组校验情况@Validated({AddGroup.class})下不生效，只会在@Validated生效； * * 5）、自定义校验 * 1）、编写一个自定义的校验注解 * 2）、编写一个自定义的校验器 ConstraintValidator * 3）、关联自定义的校验器和自定义的校验注解 * @Documented * @Constraint(validatedBy = { ListValueConstraintValidator.class【可以指定多个不同的校验器，适配不同类型的校验】 }) * @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE }) * @Retention(RUNTIME) * public @interface ListValue { * * 4、统一的异常处理 * @ControllerAdvice * 1）、编写异常处理类，使用@ControllerAdvice。 * 2）、使用@ExceptionHandler标注方法可以处理的异常。 */  可以不带url但是如果带了就必须合法\n 自定义注解\n@Documented @Constraint(validatedBy = { ListValueConstraintValidator.class }) @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE }) @Retention(RUNTIME) public @interface ListValue { String message() default \u0026#34;{com.atguigu.common.valid.ListValue.message}\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default { }; Class\u0026lt;? extends Payload\u0026gt;[] payload() default { }; int[] vals() default { }; } @JsonInclude(JsonInclude.Include.NON_EMPTY)不是空时返回该字段信息\npath.toArray(new Long[path.size()]);//List转数组 Collections.reverse(parentPath);//翻转列表  关联表中有冗余数据需要同步更新，@Transactional级联更细需要事务控制\n涉及多张表的时候使用\nP76\nObject划分  PO(persistant object) 对应数据库某表中的一条记录 VO(value object)值对象  VO 视图对象\n功能\n 接收页面传递来的数据，封装成对象 将业务处理完成的对象封装成页面要用的数据  DAO data access object\n数据库访问对象\npublic IPage\u0026lt;T\u0026gt; page(IPage\u0026lt;T\u0026gt; page, Wrapper\u0026lt;T\u0026gt; queryWrapper) { return this.baseMapper.selectPage(page, queryWrapper); } Mybatis-Plus 需要用@Param标注\nvoid deleteBatchRelation(@Param(\u0026#34;entities\u0026#34;) List\u0026lt;AttrAttrgroupRelationEntity\u0026gt; entities); @PostMapping(\u0026#34;/attr/relation/delete\u0026#34;) public R deleteRelation(@RequestBody AttrGroupRelationVo[] vos){ attrService.deleteRelation(vos); return R.ok(); } Post请求携带Json数据需要RequestBody才能转换\nif(attrIds == null ||attrIds.size()==0){ return null; }  每次查询后需要判断非空\n 不是Json数据的请求参数\n@RequestParam Map\u0026lt;String,Object\u0026gt; params 前端传来的数据如果是可选项时要注意判断空指针，否则会出现空指针异常\n判断是空指针就不进行接下来的操作.\n87\n保存逻辑 public class SpuSaveVo { private String spuName; private String spuDescription; private Long catalogId; private Long brandId; private BigDecimal weight; private int publishStatus; private List\u0026lt;String\u0026gt; decript; private List\u0026lt;String\u0026gt; images; private Bounds bounds; private List\u0026lt;BaseAttrs\u0026gt; baseAttrs; private List\u0026lt;Skus\u0026gt; skus; } public class SpuInfoEntity implements Serializable { private static final long serialVersionUID = 1L; private Long id; private String spuName; private String spuDescription; private Long catalogId; private Long brandId; private BigDecimal weight; private Integer publishStatus; private Date createTime; private Date updateTime; } 还剩下\nprivate Bounds bounds; private List\u0026lt;BaseAttrs\u0026gt; baseAttrs; private List\u0026lt;Skus\u0026gt; skus; 字符串拼接操作\nString.join(\u0026#34;,\u0026#34;,decript) public class SkuInfoEntity implements Serializable { private static final long serialVersionUID = 1L; private Long skuId; private Long spuId; private String skuName; private String skuDesc; private Long catalogId; private Long brandId; private String skuDefaultImg; private String skuTitle; private String skuSubtitle; private BigDecimal price; private Long saleCount; } public class Skus { private List\u0026lt;Attr\u0026gt; attr; private String skuName; private BigDecimal price; private String skuTitle; private String skuSubtitle; private List\u0026lt;Images\u0026gt; images; private List\u0026lt;String\u0026gt; descar; private int fullCount; private BigDecimal discount; private int countStatus; private BigDecimal fullPrice; private BigDecimal reducePrice; private int priceStatus; private List\u0026lt;MemberPrice\u0026gt; memberPrice; } TO A微服务向B微服务发出请求需要用的是传输模型，一般放在公共模块中，命名为TO\n设置微服务内存大小  VM Options -Xms100m\n SETSESSIONTRANSACTIONISOLATIONLEVELREADUNCOMMITTED;防止添加事务后调试不方便\nmybatis默认主键是自增的，所以如果要插入值会产生错误，故要调整\nmysql连接数太多 java.sql.SQLNonTransientConnectionException: Data source rejected establishment of connection, mess\n解决方法重启mysql\n当前端传来的是0等默认数据时，不进行保存\n要先判断\njackson: date-format: yyyy-MM-dd HH:mm:ss //远程查询sku的名字 失败抛出异常不回滚 try{ R info = productFeignService.info(skuId); String skuName = (String) info.get(\u0026#34;skuInfo\u0026#34;); wareSkuEntity.setSkuName(skuName); }catch (Exception e){ e.printStackTrace(); } //远程查询sku的名字 失败抛出异常不回滚  try{ R info = productFeignService.info(skuId); Map\u0026lt;String,Object\u0026gt; data = (Map\u0026lt;String, Object\u0026gt;) info.get(\u0026#34;skuInfo\u0026#34;); wareSkuEntity.setSkuName((String) data.get(\u0026#34;skuName\u0026#34;)); }catch (Exception e){ e.printStackTrace(); } 注意返回的JSON字符串会默认转换为HashMap 而不是对象\nElasticSearch 乐观锁操作 _seq_no在每次请求修改后会+1，在高并发的情况下需要加上参数if_seq_no=1，只有当值符合的时候才能修改成功。\npost带_update 对比原来数据，如果没有变化则version序列号都不变\n没有删除type的操作\nGET bank/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;account_number\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } } ] } 在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。\n\u0026ldquo;shoud\u0026rdquo; 可以不满足，但是满足的得分较高\nfilter不会贡献相关性得分\nterm 精确字段，非文本字段\nkeyword 精确匹配，不会分词\nP 128\n整合Springboot @Test public void insertIndex() throws IOException { IndexRequest indexRequest = new IndexRequest(\u0026#34;users\u0026#34;); indexRequest.id(\u0026#34;1\u0026#34;); User user = new User(); user.setName(\u0026#34;Jane\u0026#34;); user.setAge(19); String jsonString = JSON.toJSONString(user); indexRequest.source(jsonString,XContentType.JSON);//要保存的内容用source API  IndexResponse index = client.index(indexRequest, MallElasticSearchConfig.COMMON_OPTIONS);//发动请求,第二个参数是请求中的选项  System.out.println(index); } @Test public void searchData() throws IOException { //创建检索请求  SearchRequest searchRequest = new SearchRequest(); searchRequest.indices(\u0026#34;bank\u0026#34;); searchRequest.types(\u0026#34;account\u0026#34;); //指定检索条件  SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); searchSourceBuilder.query(QueryBuilders.matchQuery(\u0026#34;address\u0026#34;,\u0026#34;mill\u0026#34;));//使用工具类创建QueryBuilder  //创建聚合请求  TermsAggregationBuilder aggregation = AggregationBuilders.terms(\u0026#34;ageAgg\u0026#34;).field(\u0026#34;age\u0026#34;).size(10); aggregation.subAggregation(AggregationBuilders.avg(\u0026#34;accountAvg\u0026#34;).field(\u0026#34;account_number\u0026#34;)); searchSourceBuilder.aggregation(aggregation); //发出请求  searchRequest.source(searchSourceBuilder); SearchResponse response = client.search(searchRequest, MallElasticSearchConfig.COMMON_OPTIONS); //处理结果  SearchHits hits = response.getHits(); SearchHit[] searchHits = hits.getHits(); for (SearchHit hit : searchHits) { String s = hit.getSourceAsString(); System.out.println(s); } Aggregations aggregations = response.getAggregations(); Terms ageAgg = aggregations.get(\u0026#34;ageAgg\u0026#34;); for (Terms.Bucket bucket : ageAgg.getBuckets()) { String keyAsString = bucket.getKeyAsString(); System.out.println(\u0026#34;年龄\u0026#34;+keyAsString+\u0026#34;-\u0026gt;\u0026#34;+bucket.getDocCount()+\u0026#34;个人\u0026#34;); } } nested嵌入式属性，否则因为扁平化处理会出现错误\nMybatis \u0026lt;select id=\u0026#34;selectSearchAttrs\u0026#34; resultType=\u0026#34;java.lang.Long\u0026#34;\u0026gt; SELECT attr_id FROM pms_attr WHERE attr_id IN \u0026lt;foreach collection=\u0026#34;attrIds\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; AND search_type = 1 \u0026lt;/select\u0026gt; 业务代码 Set\u0026lt;Long\u0026gt; searchSet = new HashSet\u0026lt;\u0026gt;(searchAttrIds); List\u0026lt;ESSkuModel.Attr\u0026gt; attrList = productAttrValueEntities.stream().filter(item -\u0026gt; { //从attrIds中过滤出所有符合searchAttrIds的值  return searchSet.contains(item.getAttrId()); }) 泛型设计\npublic class R\u0026lt;T\u0026gt; extends HashMap\u0026lt;String, Object\u0026gt; { private static final long serialVersionUID = 1L; private T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } Hash表加速判断\nMap\u0026lt;Long, Boolean\u0026gt; collect = res.getData().stream().collect(Collectors.toMap(item -\u0026gt; item.getSkuId(), item -\u0026gt; item.isHasStock())); 远程调用需要try catch\n否则一旦出现异常，后面代码全部不能执行\n疑问\nTypeReference\u0026lt;List\u0026lt;SkuHasStockVo\u0026gt;\u0026gt; typeReference = new TypeReference\u0026lt;List\u0026lt;SkuHasStockVo\u0026gt;\u0026gt;(){}; access-key: LTAI4GH6YUaRR7mC3xAv141W secret-key: P0M4V6CgXQ2fCrbPpR4aAzNQV8nTBo Nginx firewall-cmd --list-all #查看防火墙的开放端口 firewall-cmd --add-port=80/tcp --permanent #设置开放端口 firewall-cmd --reload #重启防火墙 nginx.conf http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; #配置上游服务器 upstream gulimall{ server 192.168.189.1:88; } server { listen 80; server_name gulimall.com; location / { proxy_set_header HOST $host; #请求头中host信息会随着nginx代理丢失，所以需要配置 proxy_pass http://gulimall; #代理给上游服务器 } } 网关配置 - id:gulimall_host_routeuri:lb://gulimall-productpredicates:- Host=**.gulimall.com调优参数 java **-Xmx3550m -Xms3550m -Xmn2g** **-Xss128k** **-**Xmx3550m**：设置JVM最大可用内存为3550M。 **-Xms3550m**：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 **-Xmn2g**：设置年轻代大小为2G。**整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小**。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 **-Xss128k**：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 中间件越多，性能损失越大，损失在网络交互；\nDocker yum install -y yum-utils yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum install docker-ce 设置开机自启 systemctl enable docker 常用命令 [root@localhost src]# docker exec -it redis /bin/bash #进入docker容器内部，类似一个Linux root@af2f99f3848f:/data# ls [root@localhost src]# docker exec -it redis redis-cli 127.0.0.1:6379\u0026gt; 动静分离 /usr/local/nginx/html 代码优化 在循环中查询数据库因为每次都要连接数据库会导致开销过大\n优化方法\n 调整为先将要查的数据封装成集合，然后一次连接数据库查询出所有信息 先查出所有数据然后用代码进行筛选，总共查询一次数据库  修改前\n/** * 查出所有分类并封装成3级分类 * @return */ @Override public Map\u0026lt;String, List\u0026lt;Catalog2Vo\u0026gt;\u0026gt; getCatalogJson() { //查出所有一级分类  List\u0026lt;CategoryEntity\u0026gt; level1Categories = getLevel1Categories(); Map\u0026lt;String, List\u0026lt;Catalog2Vo\u0026gt;\u0026gt; result = level1Categories.stream().collect(Collectors.toMap(k -\u0026gt; k.getCatId().toString(), v -\u0026gt; { //查所有二级分类  List\u0026lt;CategoryEntity\u0026gt; categoryEntities = baseMapper.selectList(new QueryWrapper\u0026lt;CategoryEntity\u0026gt;().eq(\u0026#34;parent_cid\u0026#34;, v.getCatId())); List\u0026lt;Catalog2Vo\u0026gt; calalog2Vos = null; if (categoryEntities != null) { calalog2Vos = categoryEntities.stream().map(item -\u0026gt; { Catalog2Vo catalog2Vo = new Catalog2Vo(v.getCatId().toString(), null, item.getCatId().toString(), item.getName()); List\u0026lt;CategoryEntity\u0026gt; level3Catalogs = baseMapper.selectList(new QueryWrapper\u0026lt;CategoryEntity\u0026gt;().eq(\u0026#34;parent_cid\u0026#34;, item.getCatId())); if(level3Catalogs!=null){ List\u0026lt;Catalog2Vo.Catalog3Vo\u0026gt; catalog3VoList = level3Catalogs.stream().map(level3Catalog -\u0026gt; { Catalog2Vo.Catalog3Vo catalog3Vo = new Catalog2Vo.Catalog3Vo(item.getCatId().toString(), level3Catalog.getCatId().toString(), level3Catalog.getName()); return catalog3Vo; }).collect(Collectors.toList()); catalog2Vo.setCatalog3List(catalog3VoList); } return catalog2Vo; }).collect(Collectors.toList()); } return calalog2Vos; })); return result; } 优化后\n/** * 查出所有分类并封装成3级分类 * @return */ @Override public Map\u0026lt;String, List\u0026lt;Catalog2Vo\u0026gt;\u0026gt; getCatalogJson() { //查出所有数据，用空间换时间  List\u0026lt;CategoryEntity\u0026gt; selectList = baseMapper.selectList(null); //查出所有一级分类  List\u0026lt;CategoryEntity\u0026gt; level1Categories = getChildren(selectList,0L); Map\u0026lt;String, List\u0026lt;Catalog2Vo\u0026gt;\u0026gt; result = level1Categories.stream().collect(Collectors.toMap(k -\u0026gt; k.getCatId().toString(), v -\u0026gt; { //查所有二级分类  List\u0026lt;CategoryEntity\u0026gt; categoryEntities = getChildren(selectList,v.getCatId()); List\u0026lt;Catalog2Vo\u0026gt; calalog2Vos = null; if (categoryEntities != null) { calalog2Vos = categoryEntities.stream().map(item -\u0026gt; { Catalog2Vo catalog2Vo = new Catalog2Vo(v.getCatId().toString(), null, item.getCatId().toString(), item.getName()); List\u0026lt;CategoryEntity\u0026gt; level3Catalogs = getChildren(selectList,item.getCatId()); if(level3Catalogs!=null){ List\u0026lt;Catalog2Vo.Catalog3Vo\u0026gt; catalog3VoList = level3Catalogs.stream().map(level3Catalog -\u0026gt; { Catalog2Vo.Catalog3Vo catalog3Vo = new Catalog2Vo.Catalog3Vo(item.getCatId().toString(), level3Catalog.getCatId().toString(), level3Catalog.getName()); return catalog3Vo; }).collect(Collectors.toList()); catalog2Vo.setCatalog3List(catalog3VoList); } return catalog2Vo; }).collect(Collectors.toList()); } return calalog2Vos; })); return result; } /** * 从categoryEntityList选出parentId符合的封装成List并返回 * @param categoryEntityList * @param parentId * @return */ private List\u0026lt;CategoryEntity\u0026gt; getChildren(List\u0026lt;CategoryEntity\u0026gt; categoryEntityList,Long parentId) { List\u0026lt;CategoryEntity\u0026gt; children = categoryEntityList.stream().filter(categoryEntity -\u0026gt; { return categoryEntity.getParentCid().equals(parentId); }).collect(Collectors.toList()); return children; } 堆外内存溢出\n/** * 1. SpringBoot2.0之后默认使用 lettuce 作为操作 redis 的客户端，lettuce 使用 Netty 进行网络通信 * 2. lettuce 的 bug 导致 Netty 堆外内存溢出 -Xmx300m Netty 如果没有指定对外内存 默认使用 JVM 设置的参数 * 可以通过 -Dio.netty.maxDirectMemory 设置堆外内存 * 解决方案：不能仅仅使用 -Dio.netty.maxDirectMemory 去调大堆外内存 * 1. 升级 lettuce 客户端 2. 切换使用 jedis * * RedisTemplate 对 lettuce 与 jedis 均进行了封装 所以直接使用 详情见：RedisAutoConfiguration 类 */ 锁 确认缓存有没有，查询数据库，将结果放入缓存作为原子性操作\n之前加锁，之后释放锁\n[root@localhost html]# docker exec -it redis redis-cli 127.0.0.1:6379\u0026gt; set lock hello NX OK 只有当不存在时候才能set，这是原子性操作(NX)\n原子性 一系列命令全成功或者全失败\n分布式锁 /** * Redis使用分布式锁 * @return */ public Map\u0026lt;String, List\u0026lt;Catalog2Vo\u0026gt;\u0026gt; getCatalogJsonFromDBWithRedisLock() throws InterruptedException { //上锁  String uuid = UUID.randomUUID().toString();//为保证在分布式系统中确认是自己的锁  Boolean lock = redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;, uuid, 300, TimeUnit.SECONDS);//原子性操作，只有一个线程能执行  if(lock){ //得到锁并加锁成功  Map\u0026lt;String, List\u0026lt;Catalog2Vo\u0026gt;\u0026gt; catalogJsonFromDB; try { //执行操作  catalogJsonFromDB = getCatalogJsonFromDB(); }finally { //无论是否发生异常都要解锁  //lua脚本原子性操作  String script = \u0026#34;if redis.call(\u0026#39;get\u0026#39;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#39;del\u0026#39;, KEYS[1]) else return 0 end\u0026#34;; redisTemplate.execute(new DefaultRedisScript\u0026lt;Long\u0026gt;(script, Long.class), Collections.singletonList(\u0026#34;lock\u0026#34;), uuid); } return catalogJsonFromDB; }else{ //自旋等待锁  Thread.sleep(100); return getCatalogJsonFromDBWithRedisLock(); } } 读写锁 只要有写操作，无论是先写还是后写都会阻塞\n/** * 读写锁测试 * @return */ @RequestMapping(\u0026#34;/write\u0026#34;) @ResponseBody public String write(){ RReadWriteLock readWriteLock = redissonClient.getReadWriteLock(\u0026#34;rw-lock\u0026#34;); //获取写锁  RLock rLock = readWriteLock.writeLock(); String s = \u0026#34;\u0026#34;; try { //上锁  rLock.lock(); s = UUID.randomUUID().toString(); Thread.sleep(3000); redisTemplate.opsForValue().set(\u0026#34;write-value\u0026#34;,s); } catch (Exception e) { e.printStackTrace(); } finally { rLock.unlock(); } return s; } @RequestMapping(\u0026#34;/read\u0026#34;) @ResponseBody public String read(){ RReadWriteLock readWriteLock = redissonClient.getReadWriteLock(\u0026#34;rw-lock\u0026#34;); //获取写锁  RLock rLock = readWriteLock.readLock(); String s = \u0026#34;\u0026#34;; try { //上锁  rLock.lock(); s = redisTemplate.opsForValue().get(\u0026#34;write-value\u0026#34;); } catch (Exception e) { e.printStackTrace(); } finally { rLock.unlock(); } return s; } 信号量可以用作系统的限流功能\n锁的粒度越细越好\n更新数据库后删除相应的缓存\n自动配置过程 1、选择导入哪种类型的配置\nstatic class CacheConfigurationImportSelector implements ImportSelector { CacheConfigurationImportSelector() { } public String[] selectImports(AnnotationMetadata importingClassMetadata) { CacheType[] types = CacheType.values(); String[] imports = new String[types.length]; for(int i = 0; i \u0026lt; types.length; ++i) { imports[i] = CacheConfigurations.getConfigurationClass(types[i]); } return imports; } } final class CacheConfigurations { private static final Map\u0026lt;CacheType, Class\u0026lt;?\u0026gt;\u0026gt; MAPPINGS; private CacheConfigurations() { } public static String getConfigurationClass(CacheType cacheType) { Class\u0026lt;?\u0026gt; configurationClass = (Class)MAPPINGS.get(cacheType); Assert.state(configurationClass != null, () -\u0026gt; { return \u0026#34;Unknown cache type \u0026#34; + cacheType; }); return configurationClass.getName(); } public static CacheType getType(String configurationClassName) { Iterator var1 = MAPPINGS.entrySet().iterator(); Entry entry; do { if (!var1.hasNext()) { throw new IllegalStateException(\u0026#34;Unknown configuration class \u0026#34; + configurationClassName); } entry = (Entry)var1.next(); } while(!((Class)entry.getValue()).getName().equals(configurationClassName)); return (CacheType)entry.getKey(); } static { Map\u0026lt;CacheType, Class\u0026lt;?\u0026gt;\u0026gt; mappings = new EnumMap(CacheType.class); mappings.put(CacheType.GENERIC, GenericCacheConfiguration.class); mappings.put(CacheType.EHCACHE, EhCacheCacheConfiguration.class); mappings.put(CacheType.HAZELCAST, HazelcastCacheConfiguration.class); mappings.put(CacheType.INFINISPAN, InfinispanCacheConfiguration.class); mappings.put(CacheType.JCACHE, JCacheCacheConfiguration.class); mappings.put(CacheType.COUCHBASE, CouchbaseCacheConfiguration.class); mappings.put(CacheType.REDIS, RedisCacheConfiguration.class); mappings.put(CacheType.CAFFEINE, CaffeineCacheConfiguration.class); mappings.put(CacheType.SIMPLE, SimpleCacheConfiguration.class); mappings.put(CacheType.NONE, NoOpCacheConfiguration.class); MAPPINGS = Collections.unmodifiableMap(mappings); } } 从容器中找RedisCacheConfiguration，如果没有就使用默认配置\n@Configuration @ConditionalOnClass({RedisConnectionFactory.class}) @AutoConfigureAfter({RedisAutoConfiguration.class}) @ConditionalOnBean({RedisConnectionFactory.class}) @ConditionalOnMissingBean({CacheManager.class}) @Conditional({CacheCondition.class}) class RedisCacheConfiguration { private final CacheProperties cacheProperties; private final CacheManagerCustomizers customizerInvoker; private final org.springframework.data.redis.cache.RedisCacheConfiguration redisCacheConfiguration; RedisCacheConfiguration(CacheProperties cacheProperties, CacheManagerCustomizers customizerInvoker, ObjectProvider\u0026lt;org.springframework.data.redis.cache.RedisCacheConfiguration\u0026gt; redisCacheConfiguration) { this.cacheProperties = cacheProperties; this.customizerInvoker = customizerInvoker; this.redisCacheConfiguration = (org.springframework.data.redis.cache.RedisCacheConfiguration)redisCacheConfiguration.getIfAvailable(); } @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) { RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(this.determineConfiguration(resourceLoader.getClassLoader())); List\u0026lt;String\u0026gt; cacheNames = this.cacheProperties.getCacheNames(); if (!cacheNames.isEmpty()) { builder.initialCacheNames(new LinkedHashSet(cacheNames)); } return (RedisCacheManager)this.customizerInvoker.customize(builder.build()); } private org.springframework.data.redis.cache.RedisCacheConfiguration determineConfiguration(ClassLoader classLoader) { if (this.redisCacheConfiguration != null) { return this.redisCacheConfiguration; } else { Redis redisProperties = this.cacheProperties.getRedis(); org.springframework.data.redis.cache.RedisCacheConfiguration config = org.springframework.data.redis.cache.RedisCacheConfiguration.defaultCacheConfig(); config = config.serializeValuesWith(SerializationPair.fromSerializer(new JdkSerializationRedisSerializer(classLoader))); if (redisProperties.getTimeToLive() != null) { config = config.entryTtl(redisProperties.getTimeToLive()); } if (redisProperties.getKeyPrefix() != null) { config = config.prefixKeysWith(redisProperties.getKeyPrefix()); } if (!redisProperties.isCacheNullValues()) { config = config.disableCachingNullValues(); } if (!redisProperties.isUseKeyPrefix()) { config = config.disableKeyPrefix(); } return config; } } } JavaBean中的属性与配置文件中的值进行绑定\n@ConfigurationProperties( prefix = \u0026#34;spring.cache\u0026#34; ) 防止缓存穿透\nspring.cache.redis.cache-null-values=trueSpringCache 常用注解  @Cacheable: Triggers cache population. @CacheEvict: Triggers cache eviction. 失效模式下 更新的方法上使用 @CachePut: Updates the cache without interfering with the method execution. @Caching: Regroups multiple cache operations to be applied on a method. 组合多个注解 @CacheConfig: Shares some common cache-related settings at class-level.  @CacheEvict(value = \u0026#34;category\u0026#34;,key = \u0026#34;\u0026#39;getLevel1Categories\u0026#39;\u0026#34;) key如果使用的是el表达式需要加上''\naccess-key: LTAI4GH6YUaRR7mC3xAv141W secret-key: P0M4V6CgXQ2fCrbPpR4aAzNQV8nTBo //将ThreadPoolConfigProperties加入容器中 @EnableConfigurationProperties(ThreadPoolConfigProperties.class) @Component //两个注解的作用相同，只能标注其中的一个，否则容器中存在2个相同的bean会报错  转发常见问题 redirectAttributes.addAttribute(\u0026#34;skuId\u0026#34;,skuId); //在session中存储数据，且只能取一次，在页面取出 redirectAttributes.addFlashAttribute(\u0026#34;skuId\u0026#34;,skuId);//数据会拼在url地址中作为参数  示例 @GetMapping(\u0026#34;/addToCart\u0026#34;) public String addToCart(@RequestParam(\u0026#34;skuId\u0026#34;)Long skuId, @RequestParam(\u0026#34;num\u0026#34;) Integer num, RedirectAttributes redirectAttributes){ try { CartItem item = cartService.addToCart(skuId,num); redirectAttributes.addAttribute(\u0026#34;skuId\u0026#34;,skuId); redirectAttributes.addFlashAttribute(\u0026#34;skuId\u0026#34;,skuId); } catch (Exception e) { e.printStackTrace(); } return \u0026#34;redirect:http://cart.gulimall.com/addToCartSuccess.html\u0026#34;; } 添加购物车和显示购物车需要经过重定向，否则用户刷新页面就会增加商品\nRabbitMq /** * 源码中使用ObjectProvider查询容器中是否有MessageConverter如果有就用容器中的 * 没有就用默认的 * @return */ @Bean public MessageConverter messageConverter(){ return new Jackson2JsonMessageConverter(); } 配置\nrabbitmq:host:192.168.91.128port:5672virtual-host:/publisher-confirms:true#发送端确认，到达brokerpublisher-returns:true#抵达队列确认template:mandatory:truelistener:direct:acknowledge-mode:manual#手动ACK,防宕机Windows查看端口占用情况 netstat -ano|findstr 9000 tasklist|findstr 19796 taskkill -pid (进程pid) -f 面试：做此项目遇到的问题和解决方法 Feign 注意远程调用接口时候需要@ResponseBody\n@GetMapping(\u0026#34;/currentUserCartItem\u0026#34;) @ResponseBody public List\u0026lt;CartItem\u0026gt; getCurrentUserCartItem(){ return cartService.getCurrentUserCartItem(); } 通过分析Feign的源码可知，Feign会根据程序编写的拦截器构造一个Request请求\n如果没有配置拦截器就用默认的，此时的Http Request 没有header 和 Body\n所以会丢失请求头\n:P268\nSpringboot注意事项 @ResponseBody @GetMapping(value = \u0026#34;/payOrder\u0026#34; , produces = \u0026#34;text/html\u0026#34;) 注释表明返回的ResponseBody的格式是html\n@GetMapping(\u0026#34;/order/order/listWithItem\u0026#34;) public R listWithItem(@RequestBody Map\u0026lt;String,Object\u0026gt; params); 远程调用建议用Json方式传递参数\n每次远程调用都使用@PostMapping和@RequestBody\nlistener:direct:acknowledge-mode:manual#手动ACK,防宕机simple:acknowledge-mode:manual必须配置手动签收，否则手动ack后会ERROR\nVMWARE问题 eth33网卡的IP地址默认是动态分配的所以需要手动设置成静态\n","date":"0001-01-01T00:00:00Z","permalink":"https://Jackwyf2019.github.io/p/gulimall%E7%AC%94%E8%AE%B0/","title":"Gulimall笔记"},{"content":"添加一组元素 public class AddingGroups { public static void main(String[] args) { Collection\u0026lt;Integer\u0026gt; collection = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1, 2, 3, 4, 5)); //用collection初始化  Integer[] moreInts = { 6, 7, 8, 9, 10 }; //数组的初始化方法  collection.addAll(Arrays.asList(moreInts)); Collections.addAll(collection, 11, 12, 13, 14, 15);//可变参数本质上是数组  Collections.addAll(collection, moreInts); List\u0026lt;Integer\u0026gt; list = Arrays.asList(16,17,18,19,20); //asList返回的List底层是数组，不能增删元素  } } 显示类型参数说明 List\u0026lt;Snow\u0026gt; snow4 = Arrays.\u0026lt;Snow\u0026gt;asList(new Light(), new Heavy(), new Slush());\nasList返回的ArrayList是Arrays的内部类\nprivate static class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements RandomAccess, java.io.Serializable{} Collection Set  HashSet 快速获取元素，存储顺序与添加顺序无关 TreeSet 按比较顺序排序 LinkedHashMap 按添加的顺序保存对象  Map  HashMap 查找速度最快 TreeMap 按比较顺序 LinkedHashMap 按插入顺序同时保留了HashMap的查找速度  Api中传引用的会用 equals()判断是否相等比如indexOf() remove()等\n改变sublist会引起原列表的改变\n@Test public void test(){ Random random = new Random(47); ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(list,1,2,3,4,5); List\u0026lt;Integer\u0026gt; subList = list.subList(1, 4); Collections.shuffle(subList); System.out.println(subList); System.out.println(list); } //[4, 3, 2]  //[1, 4, 3, 2, 5] retain() containsAll() 不关注顺序\n","date":"0001-01-01T00:00:00Z","permalink":"https://Jackwyf2019.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%94%E8%AE%B0/","title":"Java编程思想笔记"},{"content":"容器的开启和停止 删除容器之前需要先停止\n[root@localhost ~]# docker rm 3490d7c7d901 Error response from daemon: You cannot remove a running container 3490d7c7d90167692e73c2654d378b2bca02f77839e1e236d537008487fcfaa2. Stop the container before attempting removal or force remove [root@localhost ~]# docker stop 3490d7c7d901 3490d7c7d901 [root@localhost ~]# docker rm 3490d7c7d901 3490d7c7d901 命名代替ID [root@localhost ~]# docker run --name my_redis -d redis 17905e55aae8dfa53107568a997f447989b95f9d8103261ebfea2910f3f87c7d [root@localhost ~]# docker exec -it my_redis /bin/bash root@17905e55aae8:/data# redis-cli 127.0.0.1:6379\u0026gt; set arg 100 OK 127.0.0.1:6379\u0026gt; keys * 1) \u0026#34;arg\u0026#34; 127.0.0.1:6379\u0026gt; get arg \u0026#34;100\u0026#34; 127.0.0.1:6379\u0026gt; exit root@17905e55aae8:/data# exit exit [root@localhost ~]#  ","date":"0001-01-01T00:00:00Z","permalink":"https://Jackwyf2019.github.io/p/kubernetes%E7%AC%94%E8%AE%B0/","title":"Kubernetes笔记"},{"content":"Kubernetes笔记 常用命令 部署\nkubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8 #指定镜像 暴露端口\nkubectl expose deployment tomcat6 --port=80 --target-port=8080 --type=NodePort  --port=80 pod的端口 --target-port=8080 docker端口 --type=NodePort 自动分配service端口  获取所有service信息\nkubectl get svc -o wide 获取kubernetes信息\nkubectl get all #所有信息 kubectl get pods kubectl get nodes #默认名称空间 kubectl get nodes --all-namespaces 扩充\nkubectl scale --replicas=3 deployment tomcat6  scale规模 replicas复制品3份  删除\nkubectl delete [NAME] 测试\n不直接执行命令，常用于辅助\n--dry-run -o yaml将命令行转yaml\n","date":"0001-01-01T00:00:00Z","permalink":"https://Jackwyf2019.github.io/p/kubernetes%E7%AC%94%E8%AE%B0/","title":"Kubernetes笔记"},{"content":"cs : chip selector 片选信号 we : write enable MREQ : memory request 接译码器的使能端，等到电位稳定后控制器发出信号 波形图有0有1化成矩形，当变化时候有交叉\n","date":"0001-01-01T00:00:00Z","permalink":"https://Jackwyf2019.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/","title":"计算机组成原理笔记"},{"content":"字符串 public void test2(){ //array是一个引用 5行是5个指向数组的引用 类似于C语言中的int ** (也有一些区别)  //所以5行的排列顺序不一定是连续的 也可以不一样长  int[][]array=new int[5][]; array[0]=new int[3]; array[1]=new int[4]; } scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;m,\u0026amp;N); input:5 6 //scanf是从缓冲区中读取数据的，所以此时缓冲区中还剩下\\n没有被scanf读走需要 getchar() char*str=\u0026#34;hello world \u0026#34;; printf(\u0026#34;%s\u0026#34;,str); printf(\u0026#34;%p \u0026#34;,str); //字符串在常量池中，用指针指向 char*str2=\u0026#34;hello world \u0026#34;; printf(\u0026#34;%p \u0026#34;,str2); //在堆中，初始化 char s3[]=\u0026#34;hello world\u0026#34;; printf(\u0026#34;%p\u0026#34;,s3); return 0; output:hello world 00405044 00405044 0061FF0C\nchar*p=strstr(\u0026#34;hello world\u0026#34;,\u0026#34;world\u0026#34;); printf(\u0026#34;%s\u0026#34;,p); output: world int array[5]{1,2,3,4,5}; //容器内数字没有改变 for(int x:array){ x+=100; cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } //容器改变 for(int \u0026amp;x:array){ x+=100; cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 对象的构造专题 #include\u0026lt;iostream\u0026gt;using namespace std; class Student{ private: int sid ; string name ; public: Student(){ cout\u0026lt;\u0026lt;\u0026#34;Student()\u0026#34;\u0026lt;\u0026lt;endl; } Student(int sid , string name){ this-\u0026gt;sid=sid;//等号为赋值，不是初始化  this-\u0026gt;name=name ; cout\u0026lt;\u0026lt;\u0026#34;student(int,string)\u0026#34;\u0026lt;\u0026lt;endl; } }; int main(){ int num(122); cout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; int array[]={1,2,3,4,5}; int array2[]{1,2,3,4,5}; Student stu;//用默认构造函数Student()创建对象  Student zs(1001,\u0026#34;shangsan\u0026#34;);//用构造函数创建对象  Student ls{1002,\u0026#34;lisi\u0026#34;}; Student ww={1003,\u0026#34;wangwu\u0026#34;};//初始化 } 多态 #include\u0026lt;iostream\u0026gt;using namespace std; class People{ public: virtual void say(){cout\u0026lt;\u0026lt;\u0026#34;I\u0026#39;m a person\u0026#34;\u0026lt;\u0026lt;endl;} }; class Student : public People{ void say(){cout\u0026lt;\u0026lt;\u0026#34;I\u0026#39;m a student\u0026#34;\u0026lt;\u0026lt;endl;} }; class Teacher:public People{ public: void say(){cout\u0026lt;\u0026lt;\u0026#34;I\u0026#39;m a teacher\u0026#34;\u0026lt;\u0026lt;endl;} }; void func(People* people){ people-\u0026gt;say(); } int main(){ Student stu; Teacher tea ; //如果不是虚函数，C++为追求效率会选择静态链编，直接在编译时期就绑定People::say()的地址  //改为虚函数后，可以采用动态链接的方式，才有多态的效果，编译时不确定函数的入口地址，在运行时才确定  func(\u0026amp;stu); func(\u0026amp;tea); People \u0026amp;r=stu;//引用也有多态  r.say(); return 0; }  只要基类的方法是virtual,其所有子类的同名方法全部是虚方法  class People{ static void say(){ System.out.println(\u0026#34;I\u0026#39;m a person\u0026#34;);//没有多态性质，静态链接  } }  静态方法和对象没有关系了，只和类有关，不访问非静态的属性。静态函数静态链编。  抽象类 #include\u0026lt;iostream\u0026gt;using namespace std; class Shape{ public: virtual double area()=0; }; class Circle:public Shape{ public: double r; Circle(int r=1):r(r){} double area(){return 3.14*r*r;} }; void func(Shape \u0026amp;s){ cout\u0026lt;\u0026lt;s.area()\u0026lt;\u0026lt;endl; } int main(){ Circle c(2); func(c); return 0; } ","date":"0001-01-01T00:00:00Z","permalink":"https://Jackwyf2019.github.io/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","title":"面向对象程序设计"}]